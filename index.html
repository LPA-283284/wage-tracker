const SHEET_USERS = 'users';

// WAGE / borç kayıtları burada (sen manuel giriyorsun)
const SHEET_WAGES = 'transactions';

// Ödeme kayıtları burada (PAYMENT_CASH / PAYMENT_BANK)
const SHEET_PAYMENTS = 'status / payments';

// Advance kayıtları burada
const SHEET_ADVANCES = 'advances';

function doGet(e) {
  const p = (e && e.parameter) ? e.parameter : {};
  const action = String(p.action || 'ping').toLowerCase();
  const callback = String(p.callback || '').trim(); // JSONP

  try {
    if (action === 'ping') return respond_({ ok: true, message: 'API running' }, callback);

    const token = String(p.token || '').trim();
    const ctx = getContext_(token);

    if (action === 'summary') return respond_(getSummary_(ctx), callback);
    if (action === 'payments') return respond_(getPayments_(ctx), callback);
    if (action === 'advances') return respond_(getAdvances_(ctx), callback);

    // ---- WRITE ----

    if (action === 'add_payment') {
      requireRole_(ctx, ['ADMIN', 'PAYER', 'EDITOR']);

      const person = String(p.person || '').trim();
      const amount = Number(p.amount || 0);
      const paidBy = String(p.paid_by || ctx.name).trim();
      const note = String(p.note || '').trim();
      const date = String(p.date || isoDate_()).trim();

      const method = String(p.method || 'CASH').trim().toUpperCase(); // CASH | BANK
      const type = (method === 'BANK') ? 'PAYMENT_BANK' : 'PAYMENT_CASH';

      if (!person) throw new Error('person gerekli');
      if (!(amount > 0)) throw new Error('amount pozitif olmalı');

      const id = addPaymentRow_({
        date,
        person,
        type,
        amount,
        paid_by: paidBy,
        method,
        note
      }, ctx);

      return respond_({ ok: true, id }, callback);
    }

    if (action === 'add_advance') {
      requireRole_(ctx, ['ADMIN', 'PAYER', 'EDITOR']);

      const person = String(p.person || '').trim();
      const amount = Number(p.amount || 0);
      const givenBy = String(p.given_by || ctx.name).trim();
      const note = String(p.note || '').trim();
      const date = String(p.date || isoDate_()).trim();

      const method = String(p.method || 'CASH').trim().toUpperCase(); // CASH | BANK

      if (!person) throw new Error('person gerekli');
      if (!(amount > 0)) throw new Error('amount pozitif olmalı');

      const id = addAdvanceRow_({
        date,
        person,
        type: 'ADVANCE',
        amount,
        given_by: givenBy,
        method,
        note
      }, ctx);

      return respond_({ ok: true, id }, callback);
    }

    if (action === 'sign_tx') {
      requireRole_(ctx, ['ADMIN', 'PAYER', 'EDITOR']);

      const id = String(p.id || '').trim();
      const kind = String(p.kind || '').trim().toUpperCase(); // PAYMENT | ADVANCE
      const signature = String(p.signature || '').trim(); // data:image/png;base64,...

      if (!id) throw new Error('id gerekli');
      if (!signature) throw new Error('signature gerekli');
      if (!['PAYMENT','ADVANCE'].includes(kind)) throw new Error('kind geçersiz');

      signTx_(id, kind, signature, ctx.name);
      return respond_({ ok: true }, callback);
    }

    if (action === 'add_user') {
      requireRole_(ctx, ['ADMIN']);

      const name = String(p.name || '').trim();
      const role = String(p.role || '').trim().toUpperCase(); // VIEWER/PAYER/EDITOR/ADMIN
      if (!name) throw new Error('name gerekli');
      if (!['VIEWER','PAYER','EDITOR','ADMIN'].includes(role)) throw new Error('role geçersiz');

      const tokenNew = generateToken_();
      const user = addUser_({ name, role, token: tokenNew });
      return respond_({ ok: true, user }, callback);
    }

    if (action === 'set_user_active') {
      requireRole_(ctx, ['ADMIN']);
      const userToken = String(p.user_token || '').trim();
      const active = String(p.active || '').toUpperCase() === 'TRUE';
      if (!userToken) throw new Error('user_token gerekli');
      setUserActive_(userToken, active);
      return respond_({ ok: true }, callback);
    }

    return respond_({ ok: false, error: 'Bilinmeyen action' }, callback);

  } catch (err) {
    return respond_({ ok: false, error: String(err && err.message ? err.message : err) }, callback);
  }
}

/** JSONP response: callback varsa JS döndürür, yoksa JSON döndürür */
function respond_(obj, callback) {
  if (callback) {
    const safeCb = callback.replace(/[^\w$.]/g, '');
    const js = `${safeCb}(${JSON.stringify(obj)});`;
    return ContentService.createTextOutput(js).setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return ContentService.createTextOutput(JSON.stringify(obj)).setMimeType(ContentService.MimeType.JSON);
}

// ---------- Auth / Context ----------
function getContext_(token) {
  if (!token) throw new Error('token gerekli');

  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_USERS);
  if (!sh) throw new Error('users sheet yok');

  const values = sh.getDataRange().getValues();
  const header = values[0].map(String);
  const idx = indexMap_(header);

  for (let r = 1; r < values.length; r++) {
    const row = values[r];
    const t = String(row[idx.token] || '').trim();
    if (t === token) {
      const active = String(row[idx.active] || '').toUpperCase() === 'TRUE';
      if (!active) throw new Error('kullanıcı pasif');
      return {
        name: String(row[idx.name] || ''),
        role: String(row[idx.role] || '').toUpperCase(),
        token
      };
    }
  }
  throw new Error('token bulunamadı');
}

function requireRole_(ctx, allowed) {
  if (!allowed.includes(ctx.role)) throw new Error('yetki yok');
}

// ---------- Summary (WAGE from transactions + PAYMENTS from status / payments) ----------
function getSummary_(ctx) {
  const ss = SpreadsheetApp.getActive();

  const shW = ss.getSheetByName(SHEET_WAGES);
  if (!shW) throw new Error('transactions sheet yok');

  const shP = ss.getSheetByName(SHEET_PAYMENTS);
  if (!shP) throw new Error('status / payments sheet yok');

  const wVals = shW.getDataRange().getValues();
  const wHeader = wVals[0].map(String);
  const wIdx = indexMap_(wHeader);

  const pVals = shP.getDataRange().getValues();
  const pHeader = pVals[0].map(String);
  const pIdx = indexMap_(pHeader);

  const perPerson = {};
  let totalWage = 0;
  let totalCashPaid = 0;
  let totalBankPaid = 0;

  // WAGE totals (transactions)
  for (let r = 1; r < wVals.length; r++) {
    const row = wVals[r];
    const isDel = String(row[wIdx.is_deleted] || '').toUpperCase() === 'TRUE';
    if (isDel) continue;

    const person = String(row[wIdx.person] || '').trim();
    const type = String(row[wIdx.type] || '').trim().toUpperCase();
    const amount = Number(row[wIdx.amount] || 0);

    if (!person) continue;
    if (type !== 'WAGE') continue;

    perPerson[person] = perPerson[person] || { wage: 0, cashPaid: 0, bankPaid: 0 };
    perPerson[person].wage += amount;
    totalWage += amount;
  }

  // PAYMENTS totals (status / payments)
  for (let r = 1; r < pVals.length; r++) {
    const row = pVals[r];
    const isDel = String(row[pIdx.is_deleted] || '').toUpperCase() === 'TRUE';
    if (isDel) continue;

    const person = String(row[pIdx.person] || '').trim();
    const type = String(row[pIdx.type] || '').trim().toUpperCase();
    const amount = Number(row[pIdx.amount] || 0);

    if (!person) continue;

    perPerson[person] = perPerson[person] || { wage: 0, cashPaid: 0, bankPaid: 0 };

    if (type === 'PAYMENT_CASH') {
      perPerson[person].cashPaid += amount;
      totalCashPaid += amount;
    } else if (type === 'PAYMENT_BANK') {
      perPerson[person].bankPaid += amount;
      totalBankPaid += amount;
    }
  }

  const people = Object.keys(perPerson).sort().map(name => {
    const p = perPerson[name];
    const due = round2_(p.wage - p.cashPaid - p.bankPaid);
    return {
      person: name,
      due,
      wage_total: round2_(p.wage),
      cash_paid_total: round2_(p.cashPaid),
      bank_paid_total: round2_(p.bankPaid)
    };
  });

  const totals = {
    total_wage: round2_(totalWage),
    total_cash_paid: round2_(totalCashPaid),
    total_bank_paid: round2_(totalBankPaid),
    total_due: round2_(totalWage - totalCashPaid - totalBankPaid)
  };

  return { ok: true, me: { name: ctx.name, role: ctx.role }, totals, people };
}

// ---------- Payments list (status / payments) ----------
function getPayments_(ctx) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_PAYMENTS);
  if (!sh) throw new Error('status / payments sheet yok');

  const values = sh.getDataRange().getValues();
  const header = values[0].map(String);
  const idx = indexMap_(header);

  const payments = [];

  for (let r = 1; r < values.length; r++) {
    const row = values[r];
    const isDel = String(row[idx.is_deleted] || '').toUpperCase() === 'TRUE';
    if (isDel) continue;

    const type = String(row[idx.type] || '').trim().toUpperCase();
    if (!(type === 'PAYMENT_CASH' || type === 'PAYMENT_BANK')) continue;

    const signature = getCol_(row, idx, 'signature');

    payments.push({
      id: String(row[idx.id] || ''),
      date: String(row[idx.date] || ''),
      person: String(row[idx.person] || ''),
      type,
      amount: Number(row[idx.amount] || 0),
      paid_by: String(row[idx.paid_by] || ''),
      method: String(getCol_(row, idx, 'method') || ''),
      note: String(row[idx.note] || ''),
      created_at: String(row[idx.created_at] || ''),
      signed: Boolean(signature && String(signature).trim())
    });
  }

  payments.sort((a,b) => (a.created_at || '').localeCompare(b.created_at || '')).reverse();
  return { ok: true, payments: payments.slice(0, 200) };
}

// ---------- Advances list ----------
function getAdvances_(ctx) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_ADVANCES);
  if (!sh) throw new Error('advances sheet yok');

  const values = sh.getDataRange().getValues();
  const header = values[0].map(String);
  const idx = indexMap_(header);

  const advances = [];

  for (let r = 1; r < values.length; r++) {
    const row = values[r];
    const isDel = String(row[idx.is_deleted] || '').toUpperCase() === 'TRUE';
    if (isDel) continue;

    const type = String(row[idx.type] || '').trim().toUpperCase();
    if (type !== 'ADVANCE') continue;

    const signature = getCol_(row, idx, 'signature');

    advances.push({
      id: String(row[idx.id] || ''),
      date: String(row[idx.date] || ''),
      person: String(row[idx.person] || ''),
      type,
      amount: Number(row[idx.amount] || 0),
      given_by: String(getCol_(row, idx, 'given_by') || getCol_(row, idx, 'paid_by') || ''),
      method: String(getCol_(row, idx, 'method') || ''),
      note: String(row[idx.note] || ''),
      created_at: String(row[idx.created_at] || ''),
      signed: Boolean(signature && String(signature).trim())
    });
  }

  advances.sort((a,b) => (a.created_at || '').localeCompare(b.created_at || '')).reverse();
  return { ok: true, advances: advances.slice(0, 200) };
}

// ---------- Write rows ----------
function addPaymentRow_(t, ctx) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_PAYMENTS);
  if (!sh) throw new Error('status / payments sheet yok');

  ensureSignatureCols_(sh);

  const id = Utilities.getUuid();
  const createdAt = new Date().toISOString();

  // base columns (A..J)
  sh.appendRow([
    id,
    t.date || isoDate_(),
    t.person,
    t.type,
    Number(t.amount),
    t.paid_by || ctx.name,
    t.method || '',
    t.note || '',
    createdAt,
    'FALSE'
  ]);

  return id;
}

function addAdvanceRow_(t, ctx) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_ADVANCES);
  if (!sh) throw new Error('advances sheet yok');

  ensureSignatureCols_(sh);
  ensureCol_(sh, 'given_by'); // advances için

  const id = Utilities.getUuid();
  const createdAt = new Date().toISOString();

  // We want a stable layout similar to payments:
  // id, date, person, type, amount, given_by, method, note, created_at, is_deleted, ...signature cols...
  // If sheet header differs, we still append in that order (you should keep the header as above).
  sh.appendRow([
    id,
    t.date || isoDate_(),
    t.person,
    'ADVANCE',
    Number(t.amount),
    t.given_by || ctx.name,
    t.method || '',
    t.note || '',
    createdAt,
    'FALSE'
  ]);

  return id;
}

// ---------- Sign existing tx (payment or advance) ----------
function signTx_(id, kind, signatureDataUrl, signerName) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(kind === 'ADVANCE' ? SHEET_ADVANCES : SHEET_PAYMENTS);
  if (!sh) throw new Error('sheet yok');

  ensureSignatureCols_(sh);

  const values = sh.getDataRange().getValues();
  const header = values[0].map(String);
  const idx = indexMap_(header);

  const sigCol = idx.signature;
  const signedByCol = idx.signed_by;
  const signedAtCol = idx.signed_at;

  if (sigCol == null || signedByCol == null || signedAtCol == null) {
    throw new Error('signature kolonları eksik');
  }

  for (let r = 1; r < values.length; r++) {
    const rowId = String(values[r][idx.id] || '').trim();
    if (rowId === id) {
      const now = new Date().toISOString();
      sh.getRange(r+1, sigCol+1).setValue(signatureDataUrl);
      sh.getRange(r+1, signedByCol+1).setValue(signerName || '');
      sh.getRange(r+1, signedAtCol+1).setValue(now);
      return;
    }
  }

  throw new Error('id bulunamadı');
}

// ---------- Users ----------
function addUser_({ name, role, token }) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_USERS);
  if (!sh) throw new Error('users sheet yok');

  const values = sh.getDataRange().getValues();
  const nextId = values.length; // basit id
  sh.appendRow([String(nextId), name, role, token, 'TRUE']);
  return { user_id: String(nextId), name, role, token, active: true };
}

function setUserActive_(token, active) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_USERS);
  const values = sh.getDataRange().getValues();
  const header = values[0].map(String);
  const idx = indexMap_(header);

  for (let r = 1; r < values.length; r++) {
    const t = String(values[r][idx.token] || '').trim();
    if (t === token) {
      sh.getRange(r+1, idx.active+1).setValue(active ? 'TRUE' : 'FALSE');
      return;
    }
  }
  throw new Error('user token bulunamadı');
}

// ---------- Helpers: Ensure columns exist ----------
function ensureSignatureCols_(sh) {
  ensureCol_(sh, 'signature');
  ensureCol_(sh, 'signed_by');
  ensureCol_(sh, 'signed_at');
}

function ensureCol_(sh, colName) {
  const range = sh.getRange(1,1,1,sh.getLastColumn());
  const header = range.getValues()[0].map(h => String(h||'').trim());
  if (header.includes(colName)) return;

  // add at end
  sh.getRange(1, sh.getLastColumn()+1).setValue(colName);
}

function getCol_(row, idx, name) {
  const i = idx[name];
  if (i == null) return '';
  return row[i];
}

// ---------- Utils ----------
function indexMap_(header) {
  const m = {};
  header.forEach((h,i) => m[String(h).trim()] = i);
  return m;
}

function isoDate_() {
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return `${yyyy}-${mm}-${dd}`;
}

function round2_(n) {
  return Math.round((Number(n) + Number.EPSILON) * 100) / 100;
}

function generateToken_() {
  const raw = Utilities.getUuid().replace(/-/g,'') + Utilities.getUuid().replace(/-/g,'');
  return raw.slice(0, 40);
}
